
Nesta seção apresentamos as definições básicas para o resto do texto.

\section{Linguagem}
Trabalharemos com a linguagem lógica modal $K_n$.

\begin{definition}
	Seja $P = \{p, q, r, \dots\}$ um conjunto enumerável de símbolos proposicionais, $\Agents = \{1, 2, 3, \dots, n\}, n \in \mathbb{N}$. Definimos o conjunto de fórmulas $\mathcal{FBF}$ indutivamente.
	
	\begin{itemize}
		\item Se $\varphi \in \set{P}$ então $\varphi \in \set{FBF}$
		\item Se $\varphi \in \set{FBF}$, $\psi \in \set{FBF}$ e $\agent \in \Agents$, então $(\varphi \land \psi) \in \set{FBF}$, $(\varphi \lor \psi) \in \set{FBF}$, $(\varphi \rightarrow \psi) \in \set{FBF}$, $\nec{\agent} \varphi \in \set{FBF}$, $\pos{\agent} \varphi \in \set{FBF}$ e $\neg\varphi \in \set{FBF}$
	\end{itemize}
\end{definition}

\begin{definition}
	Denotamos por $\set{LP}$ o conjunto de literais proposicionais e por $\set{LM}$ o conjunto de literais modais.
	$\forall p \in \set{P}, \forall \agent \in \set{A}$, então $ p \in \set{LP}, \neg p \in \set{LP}, \nec{\agent} p \in \set{LM}, \nec{\agent} \neg p \in \set{LM}, \pos{\agent} p \in \set{LM}, \pos{\agent} \neg p \in \set{LM}$
\end{definition}

\begin{definition}
	Uma cláusula proposicional é uma disjunção de literais proposicionais.
\end{definition}

Seja $\Sigma = \{0, 1\}$, $\Sigma^*$ é o conjunto de todas as cadeias formadas com elementos de $\Sigma$. Em particular, $\epsilon$ representa a cadeia vazia. Construiremos cadeias em $\Sigma^*$ para codificar a posição de ocorrência de uma subfórmula em uma fórmula. Seja $inv \colon \{\text{positiva, negativa}\} \mapsto \{\text{positiva, negativa}\}$ tal que $inv(\text{positiva}) = \text{negativa}$ e $inv(\text{negativa}) = \text{positiva}$.

\begin{definition}
	Definimos a polaridade de uma subfórmula pela função $pol \colon \set{FBF} \times \set{FBF} \times \Sigma^* \mapsto \{\text{positiva, negativa}\}$.  Para $\varphi, \chi_1, \chi_2 \in \set{FBF}, s \in \Sigma^*, \agent \in \set{A}, val \in \{\text{positiva, negativa}\}$.
	
	\begin{itemize}
		\item $pol(\varphi, \varphi, \epsilon) = \text{positiva}$.
		\item Se $pol(\varphi, \chi_1 \lor \chi_2, s) = val$, então $pol(\varphi, \chi_1, s0) = pol(\varphi, \chi_2, s1) = val$
		\item Se $pol(\varphi, \chi_1 \land \chi_2, s) = val$, então $pol(\varphi, \chi_1, s0) = pol(\varphi, \chi_2, s1) = val$
		\item Se $pol(\varphi, \chi_1 \rightarrow \chi_2, s) = val$, então $pol(\varphi, \chi_1, s0) = inv(val)$ e $pol(\varphi, \chi_2, s1) = val$
		\item Se $pol(\varphi, \pos{\agent}\chi_1, s) = val$, então $pol(\varphi, \chi_1, s0) = val$
		\item Se $pol(\varphi, \nec{\agent}\chi_1, s) = val$, então $pol(\varphi, \chi_1, s0) = val$
		\item Se $pol(\varphi, \neg\chi_1, s) = val$, então $pol(\varphi, \chi_1, s0) = inv(val)$
	\end{itemize}
	
\end{definition}
Dizemos que a polaridade de $\chi_1$ em $\varphi$ na posição $s$ é $pol(\varphi, \chi_1, s)$.

\begin{definition}
	Definimos o nível modal de uma subfórmula pela função $mlevel \colon \set{FBF} \times \set{FBF} \times \Sigma^* \mapsto \mathbb{N}$. Para $\varphi, \chi_1, \chi_2 \in \set{FBF}, s \in \Sigma^*, \agent \in \set{A}, val \in \mathbb{N}$.
	
	\begin{itemize}
		\item $mlevel(\varphi, \varphi, \epsilon) = 0$.
		\item Se $mlevel(\varphi, \chi_1 \lor \chi_2, s) = val$ ou $mlevel(\varphi, \chi_1 \land \chi_2, s) = val$ ou $mlevel(\varphi, \chi_1 \rightarrow \chi_2, s) = val$, então $mlevel(\varphi, \chi_1, s0) = mlevel(\varphi, \chi_2, s1) = val$
		\item Se $mlevel(\varphi, \pos{\agent}\chi_1, s) = val$ ou $mlevel(\varphi, \nec{\agent}\chi_1, s) = val$, então $mlevel(\varphi, \chi_1, s0) = val+1$
		\item Se $mlevel(\varphi, \neg\chi_1, s) = val$, então $mlevel(\varphi, \chi_1, s0) = val$
	\end{itemize}
\end{definition}


Dizemos que o nível modal de $\chi_1$ em $\varphi$ na posição $s$ é $mlevel(\varphi, \psi, s)$.

A semântica para lógica modal proposicional é dada por estruturas de Kripke. Uma estrutura de Kripke $M$ é da forma $M = (\set{W}, \st_0, \set{R}_1, \ldots, \set{R}_{|\Agents|}, \pi)$, onde % TODO Cita
$\set{W}$ é um conjunto de mundos possíveis, $\st_0 \in \set{W}$, $\pi:\set{W} \times \set{P} \rightarrow \{\ctrue, \cfalse\}$, $\set{R}_\agent \subseteq \set{W} \times \set{W}$ para todo $\agent \in \Agents$. Dizemos que uma fórmula $\varphi$ é satisfeita na lógica modal K no modelo $M$ no mundo $\st$ se, e somente se, $\langle M,w \rangle \models \varphi$, conforme segue:

\begin{itemize}
	\item $\langle M,\st \rangle \models \varphi$, se e somente se $\varphi \in \set{P}$ e $\pi(\st, \varphi) = \ctrue$
	\item $\langle M,\st \rangle \models \neg\varphi$, se e somente se $\langle M,\st \rangle \not\models \varphi$
	\item $\langle M,\st \rangle \models (\varphi \land \psi)$, se e somente se $\langle M,\st \rangle \models \varphi$ e $\langle M,\st \rangle \models \psi $
	\item $\langle M,\st \rangle \models (\varphi \lor \psi)$, se e somente se $\langle M,\st \rangle \models \varphi$ ou $\langle M,\st \rangle \models \psi $
	\item $\langle M,\st \rangle \models (\varphi \then \psi)$, se e somente se $\langle M,\st \rangle \not\models \varphi$ ou $\langle M,\st \rangle \models \psi $
	
	\item $\langle M,\st \rangle \models \pos{\agent}\varphi$, se e somente se $\exists\st', (\st, \st') \in \set{R}_\agent, \langle M,\st' \rangle \models \varphi$
	\item $\langle M,\st \rangle \models \nec{\agent}\varphi$, se e somente se $\forall\st', (\st, \st') \in \set{R}_\agent, \langle M,\st' \rangle \models \varphi$
	
\end{itemize}

Uma fórmula $\varphi$ é localmente satisfatível se existe um modelo $M$ tal que $\langle M,\st_0 \rangle \models \varphi$. Uma formula $\varphi$ é globalmente satisfatível se existe um modelo $M$ tal que para todo $\st \in \set{W}$ temos que $\langle M,\st \rangle \models \varphi$. Escrevemos $M \models \varphi$ se, e somente se, $\langle M, \st_0 \rangle \models \varphi$

Podemos reduzir o problema de satisfatibilidade global ao problema de satisfatibilidade local com a extensão da linguagem K pelo operador universal $\nec{*}$. Seja $M = (\set{W}, \st_0, \set{R}_1, \ldots, \set{R}_{|\Agents|}, \pi)$, $\langle M,\st \rangle \models \nec{*}\varphi$ se, e somente se, para todo $\st' \in \set{W}$, $\langle M,\st \rangle \models \varphi$.

\begin{definition}
	Uma fórmula está na forma normal negada caso seja formada somente por símbolos proposicionais, $\neg$, $\land$, $\lor$, $\nec{\agent}$ e $\pos{\agent}$ para $\agent \in \set{A}$, e a negação só é aplicada a símbolos proposicionais.
\end{definition}

É importante ressaltar se $\varphi \in \set{FBF}$ que não está na forma normal negada pode ser reescrita como $\psi \in \set{FBF}$ na forma normal negada com semântica equivalente. Isto é, para todo $\langle M, w \rangle$, $\langle M, w \rangle \models \varphi$ se, e somente se, $\langle M, w \rangle \models \psi$.

\section{Forma Normal em Camadas}
O cálculo a ser apresentado utiliza uma outra linguagem chamada de Forma Normal Separada em Níveis Modais ($SNF_{ml}$).

\begin{definition}
	Uma fórmula em $SNF_{ml}$ é uma conjunção de cláusulas. Para $ml \in \Nat \cup \{*\}$ e $l_1, l_2 \in \set{LP}$, cada cláusula está em um dos três formatos:
	\begin{itemize}
		\item $ml: c$, onde $c$ é uma cláusula proposicional
		\item $ml: l_1 \rightarrow \nec{a}l_2$
		\item $ml: l_1 \rightarrow \pos{a}l_2$
	\end{itemize}
\end{definition}

A satisfatibilidade de uma fórmula em $SNF_{ml}$ é definida a partir da satisfatibilidade de $K_n$. Sejam $ml: \varphi$ e $ml: \psi$ cláusulas $SNF_{ml}$ e $M$ um modelo na lógica $K_n$.

\begin{itemize}
	\item $M \models *: \varphi$ se, e somente se, $M \models \nec{*}\varphi$.
	\item $M \models (ml: \varphi) \land (ml: \psi)$ se, e somente se, $M \models ml: \varphi$ e $M \models ml: \psi$.
	\item $M \models ml: \varphi$ se, e somente se, para todo $\st$ tal que $depth(\st) = ml$, temos $\langle M, \st \rangle \models ml: \varphi$.
\end{itemize}

Uma função de tradução de $K_n$ para $SNF_{ml}$ bem como prova de que a tradução de uma fórmula preserva satisfatibilidade podem ser encontradas em \cite{nalontocl}.

Seja $\ge$ uma ordem total sobre os símbolos proposicionais. Extendemos esta ordem para os Literais da seguinte forma: Se $p \in \set{P}$, então $\neg p \ge \neg p$ e $\neg p \ge p$; Se $p, q \in \set{P}$ e $p \ge q$, então $p \ge \neg q$.

\begin{definition}
	O literal $l$ é máximo em $\varphi \in SNF_{ml}$ se e somente se $l$ ocorre em $\varphi$ e não há $l_2 \not= l$ em $\varphi$ tal que $l_2 \ge l$.
\end{definition}

Note que podemos escolher qualquer ordem sobre os símbolos proposionais, assim $l$ pode ser máximo numa ordem e não ser máximo em outra ordem.

\section{Regras de inferência} \label{secao:regrasinf}
O cálculo dedutivo baseado em resolução $RES_{ml}$ para lógica $K_n$ foi descrito em \cite{nalontocl}. Para simplificar a descrição das regras de inferência faremos uso de uma função parcial de unificação $\sigma \colon P(\Nat \cup \{*\}) \mapsto \Nat \cup \{*\}$, tal que $\sigma(\{ml, *\}) = ml$, $\sigma(\{ml\}) = ml$, e indefinida caso contrário. As regras de inferência de $RES_{ml}$ são apresentadas na Figura~\ref{figura:regrasinf}, onde $*-1=*$ e $m$ pode ser 0. Essas regras só valem se o resultado da unificação for definido. Demostrações de correção e corretude podem ser encotradas em \cite{nalontocl}.

\begin{figure*}[t]
	\[
	\begin{array}{c}
	\begin{array}{lll}
	\textnormal{[LRES]} & \textnormal{[MRES]} & \textnormal{[GEN2]} \\
	\begin{array}{c}
	ml: (D \lor l) \\
	ml': (D' \lor \neg l) \\
	\hline
	\sigma(\{ml, ml'\}): D \lor D' \\
	\end{array}
	&
	
	\begin{array}{c}
	ml: (l_1 \rightarrow \nec{\agent} l) \\
	ml': (l_2 \rightarrow \pos{\agent} \neg l) \\
	\hline
	\sigma(\{ml, ml'\}): \neg l_1 \lor \neg l_2 \\
	\end{array}
	&
	
	\begin{array}{c}
	ml_1: (l_1' \rightarrow \nec{\agent} l_1) \\
	ml_2: (l_2' \rightarrow \nec{\agent} \neg l_1) \\
	ml_3: (l_3' \rightarrow \pos{\agent} l_2) \\
	\hline
	\sigma(\{ml_1, ml_2, ml_3\}): \neg l_1' \lor \neg l_2' \lor \neg l_3' \\
	\end{array}
	
	
	\\ \end{array} \\ \\
	
	\begin{array}{ll}
	\textnormal{[GEN1]} & \textnormal{[GEN3]} \\
	
	\begin{array}{c}
	ml_1: (l_1' \rightarrow \nec{\agent} l_1) \\
	\vdots \\
	ml_m: (l_m' \rightarrow \nec{\agent} \neg l_m) \\
	ml_{m+1}: (l' \rightarrow \pos{\agent} \neg l) \\
	ml_{m+2}: (l_1 \lor \ldots \lor l_m \lor l) \\
	\hline
	ml: \neg l_1' \lor \ldots \lor \neg l_m' \lor \neg l' \\
	ml = \sigma(\{ml_1, \ldots, ml_{m+1}, ml_{m+2}-1\}) \\
	\end{array}
	&
	\begin{array}{c}
	ml_1: (l_1' \rightarrow \nec{\agent} l_1) \\
	\vdots \\
	ml_m: (l_m' \rightarrow \nec{\agent} \neg l_m) \\
	ml_{m+1}: (l' \rightarrow \pos{\agent} l) \\
	ml_{m+2}: (l_1 \lor \ldots \lor l_m) \\
	\hline
	ml: \neg l_1' \lor \ldots \lor \neg l_m' \lor \neg l' \\
	ml = \sigma(\{ml_1, \ldots, ml_{m+1}, ml_{m+2}-1\}) \\
	\end{array}
	
	\\ \end{array} \\
	\end{array} 
	\]
	\caption{Regras de inferência}
	\label{figura:regrasinf}
\end{figure*}



\section{Algoritmo}

A seguir, descrevemos o algoritmo implementado no KSP.

\begin{algorithm}[H]
	\SetAlgoLined
	\KwResult{Satisfatibilidade da fórmula}
	
	preprocessamento-da-entrada\;
	tradução-para-SNF\;
	preprocessamento-de-clausulas\;

	$\Gamma^{lit} \leftarrow \bigcup \Gamma^{lit}_{ml}$\;
	\While{$\Gamma^{lit} \not= \emptyset$}{
		\For{todo nível modal $ml$}{
			$clausula$ $\leftarrow$ given($ml$)\;
			\If{não \textrm{redundante}($clausula$)}{
				GEN1($clausula, ml, ml - 1$)\;
				GEN3($clausula, ml, ml - 1$)\;
				LRES($clausula, ml, ml$)\;
				$\Lambda^{lit}_{ml} \leftarrow \Lambda^{lit}_{ml} \cup \{clausula\}$\;
			}
			$\Gamma^{lit}_{ml} \leftarrow \Gamma^{lit}_{ml} \setminus \{clausula\}$\;
			\If{$0: false \in \Gamma^{lit}_{0}$}{
				\Return insatisfatível\;
			}
			$\Gamma^{lit} \leftarrow \bigcup \Gamma^{lit}_{ml}$\;
		}
		\Return satisfatível\;
	}
	\caption{KSP-Proof-Search}
\end{algorithm}

KSP utiliza uma variação de conjunto de suporte, técnica que restringe os candidatos possíveis para resolução, e a demostração da correção e completude dessa extensão para $SNF_{ml}$ pode ser encontrada em \cite{nalontocl}.

Na versão para lógica clássica de conjunto de suporte o conjunto de cláusulas $\Delta$ é particionado em dois conjuntos $\Gamma$, o conjunto de suporte ou não processado, e $\Lambda$, o conjunto \textit{usable} ou processado. Cláusulas são selecionadas de $\Gamma$, e passam para $\Lambda$, para aplicação de regras de inferência, os resolventes são inseridos em $\Gamma$.

Na extensão para $SNF_{ml}$, onde as clásulas são rotuladas pelo nível modal, as clásulas de todo nível modal é particionado em três conjuntos $\Gamma^{lit}_{ml}$, $\Lambda^{lit}_{ml}$ e $\Lambda^{mod}_{ml}$. Cláusulas proposicionais são particionadas em $\Gamma^{lit}_{ml}$ e $\Lambda^{lit}_{ml}$ como no caso em lógica clássica. Clásulas modais são armazenadas em $\Lambda^{mod}_{ml}$. Note que nenhuma regra de inferência descrita na Seção \ref{secao:regrasinf} produz novas cláusulas modais.

As Linhas 1-3 aplicam algumas regras de simplificação, traduzem a fórmula para linguagem $SNF_{ml}$ e constrõem os conjuntos \textit{usable} e de suporte. As Linhas 9-11 aplicam regras de inferências descritas na Seção~\ref{secao:regrasinf}.

A função {\sf given}, Linha 7, é responsável por escolher uma cláusula dentre todas as candidatas possíveis. Cada nível modal é independente, possibilitando até estratégias diferentes em níveis diferentes. Naturalmente, a função {\sf given} só considera as cláusulas do nível modal pedido. KSP implementa cinco variações dessa função: \textit{menor}, \textit{mais antiga}, \textit{mais nova}, \textit{mínima} e \textit{máxima}; e o usuário pode escolher qual deseja utilizar.

Na variação \textit{menor}, é selecionada uma cláusula com o menor tamanho de $\Gamma^{lit}_{ml}$.

Na variação \textit{mais antiga}, é salvo a ordem nas quais as cláusulas foram adicionadas à $\Gamma^{lit}_{ml}$ e é selecionada a que foi adicionada antes de todas as outras.

\textit{Mais nova} é análoga a \textit{mais antiga}, mas é selecionada a que foi adicionada depois de todas as outras.

Em \textit{mínima}, é escolhida uma cláusula com o menor tamanho dentre as cláusulas com o menor literal máximo em $\Gamma^{lit}_{ml}$.

Em \textit{máxima}, é feita escolha análoga a \textit{mínima} mas dentre cláusulas com o maior literal máximo em $\Gamma^{lit}_{ml}$.

Neste trabalho propomos novos métodos para seleção de cláusulas e comparamos com os métodos previamente utilizados no KSP. Para comparação usaremos o \textit{benchmark} \cite{lwb} contendo 9 famílias de fórmulas e para cada família 21 fórmulas satisfatíveis e 21 insatisfatíveis.

A Tabela \ref{table:primeiro10} abaixo mostra o resultado para cada uma das cinco estratégias disponíveis no KSP. Cada célula da tabela tem a quantidade de fórmulas resolvidas em até dez segundos e a média de tempo entre as fórmulas resolvidas.

\begin{table*}[t]
	\[
\begin{array}{|c|c|c|c|c|c|}
	\hline - & \textit{mais antiga} & \textit{mais nova} & \textit{mínima} & \textit{máxima} & \textit{menor} \\

	\hline \textnormal{k\_branch\_n} & 1(0.01) & 1(0.02) & 2(4.91) & 1(0.00) & 2(4.28) \\
	\hline \textnormal{k\_branch\_p} & 2(1.54) & 1(0.00) & 3(1.38) & 1(0.00) & 3(1.38) \\
	\hline \textnormal{k\_d4\_n} & 7(1.32) & 4(1.17) & 7(0.79) & 6(1.69) & 7(2.03) \\
	\hline \textnormal{k\_d4\_p} & 21(0.14) & 21(0.16) & 21(0.04) & 21(0.18) & 21(0.04) \\
	\hline \textnormal{k\_dum\_n} & 21(0.02) & 21(0.14) & 21(0.05) & 21(0.03) & 21(0.05) \\
	\hline \textnormal{k\_dum\_p} & 21(0.09) & 21(0.36) & 21(0.04) & 21(0.10) & 21(0.04) \\
	\hline \textnormal{k\_grz\_n} & 17(1.60) & 13(0.45) & 21(0.48) & 13(2.58) & 21(0.48) \\
	\hline \textnormal{k\_grz\_p} & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) \\
	\hline \textnormal{k\_lin\_n} & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) \\
	\hline \textnormal{k\_lin\_p} & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) & 21(0.00) \\
	\hline \textnormal{k\_path\_n} & 21(0.01) & 21(0.02) & 21(0.03) & 21(0.01) & 21(0.03) \\
	\hline \textnormal{k\_path\_p} & 21(0.01) & 21(0.04) & 21(0.04) & 21(0.01) & 21(0.04) \\
	\hline \textnormal{k\_ph\_n} & 2(0.00) & 2(0.00) & 3(1.54) & 2(0.00) & 3(1.67) \\
	\hline \textnormal{k\_ph\_p} & 2(0.00) & 2(0.00) & 3(0.01) & 2(0.00) & 3(0.02) \\
	\hline \textnormal{k\_poly\_n} & 8(1.16) & 5(1.29) & 8(1.58) & 8(0.86) & 8(1.12) \\
	\hline \textnormal{k\_poly\_p} & 8(2.21) & 6(1.12) & 9(1.18) & 8(1.76) & 9(1.26) \\
	\hline \textnormal{k\_t4p\_n} & 21(0.05) & 21(0.14) & 21(0.10) & 21(0.05) & 21(0.03) \\
	\hline \textnormal{k\_t4p\_p} & 21(0.03) & 21(0.09) & 21(0.04) & 21(0.03) & 21(0.01) \\
	
	\hline
	
\end{array}
	\]
\caption{Fórmulas resolvidas em até 10 seg e tempo médio em segundos.}
\label{table:primeiro10}
\end{table*}

Os resultados indicam que o KSP é muito eficiente para a maioria das famílias independente da estratégia utilizada, mas muito pode ser melhorado em k\_branch\_n, k\_branch\_p, k\_ph\_n e k\_ph\_p. Podemos, então, buscar estratégias de seleção de cláusulas direcionadas a estas famílias.

\section{Grafo}
Um grafo é um par um ordenado $(V, E)$, onde $E \subseteq V\times V$, chamamos $V$ o conjunto de vértices e $E$ o conjunto de arestas.

\section{Matroide}
Seja $X$ um conjunto de objetos e $I \subseteq 2^X$ o conjunto de conjuntos independentes tal que:
\begin{enumerate}
	\item $\emptyset \in I$
	\item $A \in I, B \subseteq A \implies B \in I$
	\item Axioma do troco, $A \in I, B \in I, |B| > |A| \implies \exists x \in B \setminus A : A \cup \{x\} \in I$
	\item Se $A \subseteq X$ e $I$ e $I'$ são conjuntos independentes maximais de A então $|I| = |I'|$
\end{enumerate}
Então $(X, I)$ é um matroide. O problema combinatório associado a ele é: Dada um função de peso $w(e) \geq 0 ~\forall e \in X$, encontre um subconjunto independente com maior soma de pesos possível.
